<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <title>Concept Inspector</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1e2a3a;
            color: #ffffff;
            margin: 0;
            padding: 20px;
        }
        #concept-render {
            padding: 0;
        }
        #concept-input {
            width: calc(100% - 20px);
            height: 200px;
            margin-bottom: 20px;
            background-color: #2c3e50;
            color: #ffffff;
            border: 1px solid #34495e;
            padding: 10px;
            font-family: monospace;
            margin-top: 1rem;
            border-radius: 5px;
        }
        .parse-block {
            margin: 5px;
            padding: 10px;
            border-radius: 5px;
            color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .parse-block-content {
            margin-left: 20px;
            padding-left: 10px;
            border-left: 2px solid rgba(255,255,255,0.15);
        }
        .parse-block-header {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }
        .parse-block strong {
            opacity: 0.5;
            margin-right: 0.5rem;
        }
        .CONCEPT { background-color: #3498db; }
        .PARAMETERS { background-color: #2ecc71; }
        .CONTEXT { background-color: #e74c3c; }
        .TRANSFORMERS { background-color: #f39c12; }
        .PROOFS { background-color: #9469a5; }
        .EXAMPLES { background-color: #1abc9c; }
        .TYPES, .STRUCTURES, .ASSERTIONS, .NOTATION {
            background-color: rgba(255,255,255,0.15);
        }
        .error { color: #e74c3c; }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            color: #111;
            font-weight: bold;
        }
        .comment {
            color: rgba(0, 0, 0, 0.45);
            font-style: italic;
        }
        .question-mark-container {
            position: relative;
        }
        .question-mark {
            width: 20px;
            height: 20px;
            background-color: #ffffff;
            color: #1e2a3a;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: bold;
            cursor: help;
            opacity: 0.3;
        }
        .hover-panel {
            position: absolute;
            top: 0;
            left: 0;
            background-color: rgba(44, 36, 32, 0.7);
            color: #ffffff;
            padding: 1rem;
            border-radius: 5px;
            border: 1px solid #3d3531;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            font-size: 0.9rem;
            font-weight: 300;
            max-width: 25rem;
            width: 25rem;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s, visibility 0.3s;
            z-index: 10;
            backdrop-filter: blur(2px);
            pointer-events: none;
        }
        .question-mark-container:hover .hover-panel {
            opacity: 1;
            visibility: visible;
        }
        #page-title {
            display: flex;
            align-items: baseline;
            margin-bottom: 1rem;
        }
        #page-title h1 {
            margin-right: 0.5rem;
        }
        #concept-name {
            font-size: 2rem;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="page-title">
        <h1>Concept Inspector</h1>
        <div id="concept-name"></div>
    </div>
    <div id="concept-render"></div>
    <textarea id="concept-input" placeholder="Paste your ConceptScript here...">
CONCEPT Thermodynamics {
  PARAMETERS {
    R : REAL  -- Universal gas constant
    k_B : REAL  -- Boltzmann constant
    N_A : REAL  -- Avogadro's number
  }

  CONTEXT {
    // We start with the fundamental concepts and build up from there
    TYPES {
      Temperature := REAL  // in Kelvin
      Pressure := REAL     // in Pascal
      Volume := REAL       // in m^3
      Energy := REAL       // in Joules
      Entropy := REAL      // in J/K
      Mass := REAL         // in kg
      MolarMass := REAL    // in kg/mol

      // A system is the fundamental unit of study in thermodynamics
      System := STRUCTURE {
        boundary : ENUM { CLOSED, OPEN, ISOLATED }
        state_variables : StateVariables
        composition : MAP(Substance, Mass)
      }

      StateVariables := STRUCTURE {
        T : Temperature
        P : Pressure
        V : Volume
        U : Energy  // Internal energy
        S : Entropy
        H : Energy  // Enthalpy
        G : Energy  // Gibbs free energy
      }

      Substance := STRUCTURE {
        name : STRING
        molar_mass : MolarMass
        specific_heat_capacity : REAL
      }

      Process := ENUM {
        ISOTHERMAL, ISOBARIC, ISOCHORIC, ADIABATIC, ISENTROPIC
      }

      Cycle := List(Process)

      HeatEngine := STRUCTURE {
        hot_reservoir : Temperature
        cold_reservoir : Temperature
        cycle : Cycle
        efficiency : REAL
      }
    }

    // Fundamental laws and principles of thermodynamics
    STRUCTURES {
      STRUCTURE ZerothLaw {
        AXIOM ThermalEquilibrium {
          ∀ A, B, C : System .
            IN_EQUILIBRIUM(A, B) ∧ IN_EQUILIBRIUM(B, C) ⇒ IN_EQUILIBRIUM(A, C)
        }
        
        // Commentary: The Zeroth Law establishes the concept of thermal equilibrium,
        // which is fundamental to the idea of temperature. It states that if two systems
        // are in thermal equilibrium with a third system, they are in thermal equilibrium
        // with each other.
      }

      STRUCTURE FirstLaw {
        FUNC energy_balance(initial : StateVariables, final : StateVariables,
                            Q : Energy, W : Energy) -> BOOL {
          final.U - initial.U = Q - W
        }

        AXIOM ConservationOfEnergy {
          ∀ sys : System, Q : Energy, W : Energy .
            LET initial = sys.state_variables
                final = AFTER_PROCESS(sys).state_variables
            IN energy_balance(initial, final, Q, W)
        }

        // Commentary: The First Law of Thermodynamics is essentially the law of
        // conservation of energy applied to thermodynamic systems. It states that
        // the change in internal energy of a system is equal to the heat added to
        // the system minus the work done by the system.
      }

      STRUCTURE SecondLaw {
        AXIOM EntropyIncrease {
          ∀ sys : System, process : Process .
            sys.boundary = ISOLATED ⇒ ENTROPY(AFTER_PROCESS(sys)) ≥ ENTROPY(sys)
        }

        FUNC carnot_efficiency(T_h : Temperature, T_c : Temperature) -> REAL {
          1 - T_c / T_h
        }

        AXIOM CarnotEfficiency {
          ∀ engine : HeatEngine .
            engine.efficiency ≤ carnot_efficiency(engine.hot_reservoir, engine.cold_reservoir)
        }

        // Commentary: The Second Law introduces the concept of entropy and places
        // constraints on the direction of natural processes. It explains why some
        // processes occur spontaneously while others do not. The Carnot efficiency
        // represents the maximum possible efficiency for any heat engine operating
        // between two temperature reservoirs.
      }

      STRUCTURE ThirdLaw {
        AXIOM ZeroEntropy {
          ∀ sys : System .
            LIMIT(sys.state_variables.T, 0) ⇒ LIMIT(sys.state_variables.S, 0)
        }

        // Commentary: The Third Law states that the entropy of a perfect crystal
        // at absolute zero temperature is zero. This law provides an absolute
        // reference point for the determination of entropy at other temperatures.
      }

      // Equations of state relate state variables to each other
      STRUCTURE EquationsOfState {
        FUNC ideal_gas_law(n : REAL, T : Temperature, P : Pressure, V : Volume) -> BOOL {
          P * V = n * R * T
        }

        FUNC van_der_waals(n : REAL, T : Temperature, P : Pressure, V : Volume, 
                           a : REAL, b : REAL) -> BOOL {
          (P + a * (n/V)^2) * (V - n*b) = n * R * T
        }

        // Commentary: Equations of state, like the ideal gas law and van der Waals
        // equation, describe the relationship between state variables. The ideal gas
        // law is simpler but less accurate for real gases, while the van der Waals
        // equation accounts for molecular size and interactions.
      }
    }

    NOTATION {
      Δ := Change in
      ∂ := Partial derivative
      ∫ := Integral
      Σ := Sum
      ∞ := Infinity
      ∝ := Proportional to
    }

    // Key thermodynamic relations and principles
    ASSERTIONS {
      AXIOM EquipartitionOfEnergy {
        ∀ sys : System, DOF : INT .
          sys.state_variables.U ≈ DOF * 1/2 * k_B * sys.state_variables.T * N_particles(sys)
      }

      // Commentary: The equipartition theorem relates the average energy per degree
      // of freedom to the temperature, providing a link between microscopic and
      // macroscopic descriptions of a system.

      AXIOM MaxwellRelations {
        ∀ sys : System .
          (∂sys.state_variables.U/∂sys.state_variables.V)_T = 
            sys.state_variables.T * (∂sys.state_variables.P/∂sys.state_variables.T)_V - sys.state_variables.P
        ∧ (∂sys.state_variables.H/∂sys.state_variables.P)_T = 
            sys.state_variables.V - sys.state_variables.T * (∂sys.state_variables.V/∂sys.state_variables.T)_P
        ∧ (∂sys.state_variables.G/∂sys.state_variables.P)_T = sys.state_variables.V
        ∧ (∂sys.state_variables.G/∂sys.state_variables.T)_P = -sys.state_variables.S
      }

      // Commentary: The Maxwell relations are a set of equations that relate partial
      // derivatives of thermodynamic quantities. They are extremely useful in
      // deriving various thermodynamic relationships and in solving practical problems.
    }
  }

  // Transformations representing key thermodynamic processes
  TRANSFORMERS {
    REWRITE IsothermalProcess(sys : System, ΔV : Volume) -> System {
      LET final_V = sys.state_variables.V + ΔV
          final_P = sys.state_variables.P * sys.state_variables.V / final_V
      IN System {
        sys with state_variables.V = final_V, 
                  state_variables.P = final_P
      }
    }

    SIMPLIFY AdiabaticProcess(sys : System, γ : REAL, ΔV : Volume) -> System {
      LET final_V = sys.state_variables.V + ΔV
          final_P = sys.state_variables.P * (sys.state_variables.V / final_V)^γ
          final_T = sys.state_variables.T * (final_V / sys.state_variables.V)^(1-γ)
      IN System {
        sys with state_variables.V = final_V,
                  state_variables.P = final_P,
                  state_variables.T = final_T
      }
    }

    // Commentary: These transformers represent key thermodynamic processes.
    // The isothermal process occurs at constant temperature, while the adiabatic
    // process occurs without heat transfer. The adiabatic process is characterized
    // by the ratio of specific heats, γ.

    REWRITE EntropyChange(initial : StateVariables, final : StateVariables) -> Entropy {
      ∫(initial.T -> final.T) (∂Q/T)
    }

    // Commentary: This transformer calculates the change in entropy between two
    // states. For reversible processes, this is equal to the integral of dQ/T.
  }

  // Key thermodynamic principles demonstrated through proofs
  PROOFS {
    THEOREM ClausiusInequality {
      ∀ sys : System, cycle : Cycle .
        ∮(cycle) (∂Q/T) ≤ 0
    }
    PROOF {
      <1> For any cyclic process, ΔS_system = 0
      <2> ∂Q/T = dS_system + dS_surroundings
      <3> ∮(cycle) dS_system = 0 (cyclic process)
      <4> ∮(cycle) (∂Q/T) = ∮(cycle) dS_surroundings
      <5> By Second Law, dS_surroundings ≥ 0
      ∴ ∮(cycle) (∂Q/T) ≤ 0
      □
    }

    // Commentary: The Clausius Inequality is a mathematical statement of the Second
    // Law of Thermodynamics. It states that for any cyclic process, the integral
    // of dQ/T is less than or equal to zero, with equality holding for reversible processes.

    THEOREM ImpossibilityOfPerpetualMotion {
      ∄ engine : HeatEngine .
        engine.efficiency > carnot_efficiency(engine.hot_reservoir, engine.cold_reservoir)
    }
    PROOF {
      ASSUME ∃ engine : HeatEngine . 
        engine.efficiency > carnot_efficiency(engine.hot_reservoir, engine.cold_reservoir)
      <1> This engine would violate the Second Law
      <2> It could be used to construct a perpetual motion machine of the second kind
      <3> This contradicts the Second Law of Thermodynamics
      ∴ No such engine can exist
      □
    }

    // Commentary: This theorem demonstrates the impossibility of creating a perpetual
    // motion machine, which is a direct consequence of the Second Law of Thermodynamics.
    // It shows that no heat engine can be more efficient than a Carnot engine operating
    // between the same temperature reservoirs.
  }

  // Practical applications and examples
  EXAMPLES {
    EXAMPLE IdealGasExpansion {
      LET sys = System {
        boundary = CLOSED,
        state_variables = StateVariables {
          T = 300,  // K
          P = 101325,  // Pa (1 atm)
          V = 0.0224,  // m^3 (22.4 L)
          U = 3744.6,  // J (for monatomic ideal gas)
          S = 130.6,  // J/K
          H = 3970.8,  // J
          G = 3578.0   // J
        },
        composition = { "Argon" -> 0.039948 }  // kg (1 mol)
      }

      LET expanded_sys = IsothermalProcess(sys, 0.0224)  // Double the volume

      ASSERT expanded_sys.state_variables.P ≈ 50662.5  // Pa (0.5 atm)
      ASSERT expanded_sys.state_variables.U = sys.state_variables.U  // Internal energy unchanged in isothermal process
      ASSERT expanded_sys.state_variables.S > sys.state_variables.S  // Entropy increases

      // Work done by the gas during expansion:
      LET W = sys.state_variables.P * sys.state_variables.V * LN(2)
      ASSERT W ≈ 1585.2  // J

      // Heat absorbed by the gas (equal to work for isothermal process):
      LET Q = W
      ASSERT Q ≈ 1585.2  // J

      // Entropy change:
      LET ΔS = EntropyChange(sys.state_variables, expanded_sys.state_variables)
      ASSERT ΔS ≈ Q / sys.state_variables.T ≈ 5.284  // J/K
    }

    // Commentary: This example demonstrates the application of thermodynamic
    // principles to a practical scenario - the isothermal expansion of an ideal gas.
    // It shows how to calculate key quantities like work, heat transfer, and entropy
    // change, and illustrates the relationships between different state variables.

    EXAMPLE CarnotCycle {
      LET engine = HeatEngine {
        hot_reservoir = 600,  // K
        cold_reservoir = 300,  // K
        cycle = [ISOTHERMAL, ADIABATIC, ISOTHERMAL, ADIABATIC],
        efficiency = carnot_efficiency(600, 300)
      }

      ASSERT engine.efficiency = 0.5  // 50% efficient

      // For 1 mol of ideal monatomic gas (Argon):
      LET sys = System {
        boundary = CLOSED,
        state_variables = StateVariables {
          T = 600,  // K
          P = 202650,  // Pa (2 atm)
          V = 0.0224,  // m^3
          U = 7489.2,  // J
          S = 144.4,  // J/K
          H = 7941.6,  // J
          G = 7156.0   // J
        },
        composition = { "Argon" -> 0.039948 }  // kg (1 mol)
      }

      // Step 1: Isothermal expansion at T_h
      LET sys1 = IsothermalProcess(sys, 0.0224)
      // Step 2: Adiabatic expansion
      LET sys2 = AdiabaticProcess(sys1, 5/3, 0.0224)
      // Step 3: Isothermal compression at T_c
      LET sys3 = IsothermalProcess(sys2, -0.0336)
      // Step 4: Adiabatic compression
      LET sys4 = AdiabaticProcess(sys3, 5/3, -0.0336)

      ASSERT sys4.state_variables ≈ sys.state_variables  // Cycle returns to initial state

      LET Q_h = 3170.4  // J (heat absorbed from hot reservoir)
      LET Q_c = 1585.2  // J (heat rejected to cold reservoir)
      LET W = Q_h - Q_c  // Net work done by the engine

      ASSERT W ≈ 1585.2  // J
      ASSERT W / Q_h
    </textarea>
    <script>
    (()=>{
    const M=['CONCEPT','PARAMETERS','CONTEXT','TRANSFORMERS','PROOFS','EXAMPLES'],
    C=['TYPES','STRUCTURES','ASSERTIONS','NOTATION'],
    EXPLANATIONS = {
        CONCEPT: "The outermost structure used in ConceptScript: they are formal-ish models of concepts in general.",
        PARAMETERS: "Top level parameters to the Concept.",
        CONTEXT: "This is where the meat of the concept is expressed; it also establishes a linguistic context for use in the proofs and examples below.",
        TRANSFORMERS: "These are basically just functions, though their original design was inspired by proof tactics and were previously only used in that context, simplifying and reusing proof steps. Now they may also be used in the examples.",
        PROOFS: "When generating a Concept theorems may be selected and proven by the LLM, or a user may request that certain theorems be included (proofs will still be generated automatically) in order to attempt to impose requirements on the generated Concept. An example would be that if you're generating an algorithm concept and want it to have some specific complexity characteristics, you could request a theorem demonstrating this. The extent to which this actually works has not been fully verified.",
        EXAMPLES: "Gives concrete instances of the concept being defined.",
        TYPES: "This is a mechanism to allow the LLM to define the basic primitives of the 'language' it will speak of in the rest of the Concept. Past versions have experimented with varying degrees of specificity in defining allowed types, e.g. linear, dependendent, algebraic. The current version leaves this pretty open-ended; it's not clear at this point what the best approach is.",
        STRUCTURES: "These are kind of a blend between objects and functions: they're basically just a way of grouping together related elements, but they can also take parameters and extend other structures.",
        ASSERTIONS: "States claims or conditions that must be true in terms of the defined types and structures.",
        NOTATION: "Allows the LLM to define custom notation as a way of allowing more economical expression throughout the Concept."
    },
    COLORS = [
        '#3498db', '#2ecc71', '#e74c3c', '#f39c12', '#9b59b6', '#1abc9c'
    ],
    P=s=>{
        let r={},l=s.split('\n'),i=0,
        E=(s,k)=>{
            let t=[],i=s,b=0,f=0;
            while(i<l.length){
                let n=l[i];
                t.push(n);
                if(n.includes('{')){b++;f=1}
                if(n.includes('}'))b--;
                if(f&&b===0)break;
                if(k.some(w=>l[i+1]&&l[i+1].trim().startsWith(w)))break;
                i++
            }
            return{content:t.join('\n'),endIndex:i}
        },
        X=(t,b)=>{
            let s=t.indexOf(b);
            if(s<0)return'';
            let u=t.slice(s),a=0,
            e=u.split('\n').findIndex((n,i)=>{
                if(n.includes('{'))a++;
                if(n.includes('}'))a--;
                return(a===0&&i>0)||(i>0&&C.some(k=>n.trim().startsWith(k)))
            });
            return e<0?u:u.split('\n').slice(0,e+1).join('\n')
        };
        while(i<l.length){
            let n=l[i].trim(),k=M.find(b=>n.startsWith(b));
            if(k){
                let{content:t,endIndex:j}=E(i,M);
                if(k==='CONTEXT'){
                    r[k]={_raw:n};
                    C.forEach(b=>r[k][b]=X(t,b))
                } else {
                    r[k]=t;
                }
                i=j
            }
            i++
        }
        return r
    },
    V=t=>t.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;"),
    H=t=>t.split('\n').map(l=>{
        let[a,b]=l.split(/--(.+)/);
        return b?a+`<span class="comment">--${b}</span>`:l.trim().startsWith('//')?`<span class="comment">${l}</span>`:l
    }).join('\n'),
    Q=(k)=>`<div class="question-mark-container"><div class="question-mark">?</div><div class="hover-panel">${EXPLANATIONS[k]||''}</div></div>`,
    G=r=>{
        let h='';
        for(let[k,v]of Object.entries(r))
            h+=B(k,v);
        return h
    },
    B=(k,v)=>{
        let t='';
        if(k==='CONTEXT'){
            t+=`<pre>${H(V(v._raw))}</pre>`;
            for(let[s,u]of Object.entries(v)){
                if(s!=='_raw'){
                    t+=B(s,u.replace(/^\s{2}/gm, ''));
                }
            }
        } else if(typeof v==='string'){
            t=`<pre>${H(V(v))}</pre>`;
        } else if(typeof v==='object'&&v!==null){
            for(let[s,u]of Object.entries(v)){
                if(s!=='_raw'){
                    t+=B(s,u);
                }
            }
        } else {
            t=`<pre>${H(V(String(v)))}</pre>`;
        }
        return`<div class="parse-block ${k}"><div class="parse-block-header"><strong>${V(k)}</strong>${Q(k)}</div><div class="parse-block-content">${t}</div></div>`
    },
    U=()=>{
        const i=document.getElementById('concept-input'),
              r=document.getElementById('concept-render');
        if(!i||!r){console.error("Required DOM elements not found");return}
        try{
            const t=P(i.value);
            r.innerHTML=G(t);
            updateConceptName(t.CONCEPT);
        }catch(e){
            console.error("Parsing error:",e);
            r.innerHTML=`<div class="error">Parsing Error: ${V(e.message)}</div>`;
            updateConceptName();
        }
    },
    D=(f,w)=>{
        let t;
        return function(...a){
            clearTimeout(t);
            t=setTimeout(()=>f.apply(this,a),w)
        }
    },
    updateConceptName=(conceptText)=>{
        const nameElement = document.getElementById('concept-name');
        if (conceptText) {
            const match = conceptText.match(/CONCEPT\s+(\w+)/);
            if (match) {
                const name = match[1];
                nameElement.innerHTML = name.split('').map((char, index) => 
                    `<span style="color:${COLORS[index % COLORS.length]}">${char}</span>`
                ).join('');
                nameElement.innerHTML = ": " + nameElement.innerHTML
            } else {
                nameElement.textContent = '';
            }
        } else {
            nameElement.textContent = '';
        }
    };
    const Y=D(U,300);
    const I=document.getElementById('concept-input');
    I?(I.addEventListener('input',Y),U()):console.error("Input element not found");
    })();
    </script>
</body>
</html>